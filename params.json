{"name":"Iqeo-conf","body":"# Iqeo::Configuration\r\n\r\nA DSL representing configuration files.\r\n\r\n## Installation\r\n\r\nIt`s a gem...\r\n\r\n    $ gem install iqeo-conf\r\n\r\n## Usage\r\n\r\nRequire 'iqeo/configuration' and optionally include Iqeo namespace:\r\n\r\n```ruby\r\nrequire 'iqeo/configuration'\r\ninclude Iqeo\r\n```\r\n\r\n### Create configuration\r\n\r\nThere are three ways to create configurations; explicit, block DSL, eval DSL.\r\n\r\n#### Explicit\r\n\r\nCall Configuration#new without a block.\r\nExplicitly call methods on instance to configure instance.\r\n\r\n```ruby\r\nconf = Configuration.new\r\nconf.alpha   1\r\nconf.bravo   2.0\r\nconf.charlie :three\r\nconf.delta   \"four\"\r\n```\r\n\r\n#### Block DSL\r\n\r\nCall Configuration#new with a block that expects a variable, a new instance will be yielded.\r\nWithin block, call methods on yielded instance to configure.\r\n\r\n```ruby\r\nconf = Configuration.new do |c|\r\n  c.alpha   1\r\n  c.bravo   2.0\r\n  c.charlie :three\r\n  c.delta   \"four\"\r\nend\r\n```\r\n\r\n#### Eval DSL\r\n\r\nCall Configuration#new with a block that does not expect a variable, contents of the block are eval`d in the context of the new instance.\r\nCall methods with implied self to configure instance.\r\n\r\n```ruby\r\nconf = Configuration.new do\r\n  alpha   1\r\n  bravo   2.0\r\n  charlie :three\r\n  delta   \"four\"\r\nend\r\n```\r\n\r\n### Read configuration\r\n\r\nAll examples above result in the same configuration.\r\nConfiguration settings can be retrieved directly or indirectly.\r\n\r\n#### Directly\r\n\r\n##### Named method\r\n\r\n```ruby\r\nconf.alpha        # => 1\r\nconf.bravo        # => 2.0\r\nconf.charlie      # => :three\r\nconf.delta        # => \"four\"\r\n```\r\n\r\n##### [ 'string' ]\r\n\r\n```ruby\r\nconf['alpha']     # => 1\r\nconf['bravo']     # => 2.0\r\nconf['charlie']   # => :three\r\nconf['delta']     # => \"four\"\r\n```\r\n\r\n##### [ :symbol ]\r\n\r\n```ruby\r\nconf[:alpha]      # => 1\r\nconf[:bravo]      # => 2.0\r\nconf[:charlie]    # => :three\r\nconf[:delta]      # => \"four\"\r\n```\r\n\r\n#### Indirectly\r\n\r\nThe underlying storage is an indifferent hash, so the usual Hash and Enumerable methods work.\r\n\r\n##### Hash & Enumerable methods\r\n\r\n```ruby\r\nconf.size                           # => 4\r\nconf.keys                           # => [ 'alpha', 'bravo', 'charlie', 'delta' ]\r\nconf.collect { |key,value| value }  # => [ 1, 2.0, :three, 'four' ]\r\n```\r\n\r\n## Features\r\n\r\n* settings by named methods\r\n* settings by '[]' & '[]='\r\n* settings & locals with '='\r\n* referencing existing settings\r\n* nested configurations\r\n* inheritance & override\r\n* read from string, at creation, or after - merged & nested\r\n* load from filename, at creation, or after - merged & nested\r\n* defaults\r\n* merge configurations\r\n* blank slate for DSL\r\n\r\n## Fancy usage\r\n\r\n* Dynamic settings by '[]' & '[]=' & 'self'\r\n* Multiple configuration files\r\n* Hierarchial configuration files\r\n\r\n## License\r\n\r\nCopyright Gerard Fowley (gerard.fowley@iqeo.net).\r\n\r\nLicensed under GPL Version 3 license.\r\nSee LICENSE file.\r\n","tagline":"A DSL for writing configuration files...","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}